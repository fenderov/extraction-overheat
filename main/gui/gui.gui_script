local MOVE_BUTTON = "move/button/base"
local BUILD_BUTTON = "build/button/base"
local BACK_BUTTON = "back/button/base"
local ACTION_BUTTON_Y_STEP = -200
local BUILD_BUTTON_X_STEP = 300
local END_TURN_BUTTON = "end_turn/base"
local BUILD_FIELD = "build_box"
local BUILD_BUTTON_BOX = "build_button/box"
local BUILD_BUTTON_PIC = "build_button/hex_pic"
local BUILD_BUTTON_WOOD_TXT = "build_button/wood_cost"
local BUILD_BUTTON_STONE_TXT = "build_button/stone_cost"

local function render_button(self, button_url, message_id)
	local button = gui.get_node(button_url)
	self.active_buttons[message_id] = button
	gui.set_enabled(button, true)
end

local function render_action(self, options)
	local x = 0
	local y = 0
	if options.move ~= nil then
		render_button(self, MOVE_BUTTON, options.move)
		gui.set_position(self.active_buttons[options.move], vmath.vector3(x, y, 0))
		y = y + ACTION_BUTTON_Y_STEP
	end
	if options.build ~= nil then
		render_button(self, BUILD_BUTTON, options.build)
		gui.set_position(self.active_buttons[options.build], vmath.vector3(x, y, 0))
		y = y + ACTION_BUTTON_Y_STEP
	end
	if options.back ~= nil then
		render_button(self, BACK_BUTTON, options.back)
		gui.set_position(self.active_buttons[options.back], vmath.vector3(x, y, 0))
		y = y + ACTION_BUTTON_Y_STEP
	end
end

local function render_build(self, options)
	local x = 300
	local y = -300
	gui.set_enabled(gui.get_node(BUILD_FIELD), true)
	for option, cost in pairs(options) do
		local clones = gui.clone_tree(gui.get_node(BUILD_BUTTON_BOX))
		gui.set_enabled(clones[BUILD_BUTTON_BOX], true)
		gui.set_position(clones[BUILD_BUTTON_BOX], vmath.vector3(x, y, 0))
		self.active_buttons[hash(option)] = clones[BUILD_BUTTON_BOX]
		self.build_buttons[hash(option)] = clones[BUILD_BUTTON_BOX]
		gui.play_flipbook(clones[BUILD_BUTTON_PIC], option)
		x = x + BUILD_BUTTON_X_STEP
		local wood = clones[BUILD_BUTTON_WOOD_TXT]
		gui.set_text(wood, "Wood: " .. cost.wood)
		local stone = clones[BUILD_BUTTON_STONE_TXT]
		gui.set_text(stone, "Stone: " .. cost.stone)
	end
end

local function erase_build(self)
	gui.set_enabled(gui.get_node(BUILD_FIELD), false)
	for option, clone_base in pairs(self.build_buttons) do
		gui.delete_node(clone_base)
	end
	self.build_buttons = {}
end

local function clear_gui(self)
	for message_id, button in pairs(self.active_buttons) do
		gui.set_enabled(button, false)
		self.active_buttons[message_id] = nil
	end
	erase_build(self)
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.active_buttons = {}
	self.build_buttons = {}
end

function on_message(self, message_id, message, sender)
	if message_id == hash("render") then
		clear_gui(self)
		if message.end_turn ~= nil then
			render_button(self, END_TURN_BUTTON, message.end_turn)
		end
		if message.action ~= nil then
			render_action(self, message.action)
		end
		if message.build ~= nil then
			render_build(self, message.build)
		end
	end
	if message_id == hash("update_resources") then
		local food = gui.get_node("food_res_txt")
		gui.set_text(food, "Food: " .. message.food)
		local wood = gui.get_node("wood_res_txt")
		gui.set_text(wood, "Wood: " .. message.wood)
		local stone = gui.get_node("stone_res_txt")
		gui.set_text(stone, "Stone: " .. message.stone)
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released then
		for message_id, node in pairs(self.active_buttons) do
			if gui.pick_node(node, action.x, action.y) then
				msg.post("game", message_id)
			end
		end
	end
end
