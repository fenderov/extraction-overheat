TILE_WIDTH = 256
TILE_HEIGHT = 384
PLAY_ZONE_PADDING = 10
SCREEN_WIDTH = 1920
GUI_PLAY_ZONE_WIDTH = 1300
GUI_PLAY_ZONE_HEIGHT = 1080
PLAY_ZONE_WIDTH = GUI_PLAY_ZONE_WIDTH - PLAY_ZONE_PADDING * 2
PLAY_ZONE_HEIGHT = GUI_PLAY_ZONE_HEIGHT - PLAY_ZONE_PADDING * 2
X_SCALED_OFFSET = 0
Y_SCALED_OFFSET = TILE_HEIGHT / 6
X_OFFSET = 0
Y_OFFSET = 0
Z_SCALE = -0.001
UNIX_OFFSET = 0
UNIT_X_SCALED_OFFSET = 0
UNIT_Y_SCALED_OFFSET = TILE_HEIGHT / 6 - 32

local camera = require "orthographic.camera"

function world_to_tile(self, v)
	ox = ((v.x - X_OFFSET) / self.scale - X_SCALED_OFFSET) / TILE_WIDTH * 2
	oy = ((v.y - Y_OFFSET) / self.scale - Y_SCALED_OFFSET) / TILE_HEIGHT * 2
	tx = math.floor(ox)
	ty = math.floor(oy)
	x = ox - tx
	y = oy - ty
	if (tx + ty) % 2 == 0 then
		if x + 3 * y > 1 then
			tx = tx + 1
			ty = ty + 1
		end
	else
		if -x + 3 * y > 0 then
			ty = ty + 1
		else
			tx = tx + 1
		end
	end
	return tx, ty
end

function tile_to_world(self, x, y)
	return vmath.vector3(
	(x * TILE_WIDTH / 2 + X_SCALED_OFFSET) * self.scale + X_OFFSET,
	(y * TILE_HEIGHT / 2 + Y_SCALED_OFFSET) * self.scale + Y_OFFSET,
	y * Z_SCALE
	)
end

function unit_to_world(self, x, y)
	return vmath.vector3(
	(x * TILE_WIDTH / 2 + UNIT_X_SCALED_OFFSET) * self.scale + X_OFFSET,
	(y * TILE_HEIGHT / 2 + UNIT_Y_SCALED_OFFSET) * self.scale + Y_OFFSET,
	0)
end

function map_update_tile(self, x, y)
	if self.map[x][y].visible then
		if self.map[x][y].id == nil then
			self.map[x][y].id = factory.create("#hex_factory", tile_to_world(self, x, y), nil, nil, self.scale)
		end
	else
		if self.map[x][y].id ~= nil then
			go.delete(self.map[x][y].id)
			self.map[x][y].id = nil
		end
		return
	end
	if self.map[x][y].unit.type == Unit.WORKER then
		if self.map[x][y].unit.id == nil then
			self.map[x][y].unit.id = factory.create("#unit_factory", unit_to_world(self, x, y), nil, nil, self.scale)
		end
	else
		if self.map[x][y].unit.id ~= nil then
			go.delete(self.map[x][y].unit.id)
			self.map[x][y].unit.id = nil
		end
	end
	if self.map[x][y].building == Building.FARM then
		if self.map[x][y].active then
			msg.post(self.map[x][y].id, "play_animation", {id = hash("farm")})
		else
			msg.post(self.map[x][y].id, "play_animation", {id = hash("farm_not_active")})
		end
	elseif self.map[x][y].building == Building.SAWMILL then
		if self.map[x][y].active then
			msg.post(self.map[x][y].id, "play_animation", {id = hash("sawmill")})
		else
			msg.post(self.map[x][y].id, "play_animation", {id = hash("sawmill_not_active")})
		end
	else
		if self.map[x][y].active then
			msg.post(self.map[x][y].id, "play_animation", {id = hash("hex_base_active")})
		else
			msg.post(self.map[x][y].id, "play_animation", {id = hash("hex_base_not_active")})
		end
	end
	go.animate(self.map[x][y].id, "scale", go.PLAYBACK_ONCE_FORWARD, self.scale, go.EASING_OUTBOUNCE, 1)
	go.animate(self.map[x][y].id, "position", go.PLAYBACK_ONCE_FORWARD, tile_to_world(self, x, y), go.EASING_OUTBOUNCE, 1)
	if self.map[x][y].unit.id ~= nil then
		go.animate(self.map[x][y].unit.id, "scale", go.PLAYBACK_ONCE_FORWARD, self.scale, go.EASING_OUTBOUNCE, 1)
		go.animate(self.map[x][y].unit.id, "position", go.PLAYBACK_ONCE_FORWARD, unit_to_world(self, x, y), go.EASING_OUTBOUNCE, 1)
	end
	-- go.set(self.map[x][y].id, "scale", self.scale)
	-- go.set(self.map[x][y].id, "position", tile_to_world(self, x, y))
end

function map_update(self)
	for r = 0, MAP_RADIUS do
		for x, y in circle_coordinates(r) do
			map_update_tile(self, x, y)
		end
	end
end

function map_set_radius(self, r)
	self.radius = r
	self.scale = math.min(PLAY_ZONE_WIDTH / TILE_WIDTH / (2 * r + 1), PLAY_ZONE_HEIGHT / TILE_WIDTH / (1.5 * r + 1))
	map_update(self)
end

MAP_RADIUS = 4

Landscape = {
	PLAINS = 0,
	FOREST = 1,
	STONES = 2
}

Building = {
	NONE = 0,
	FARM = 1,
	SAWMIL = 2
}

Unit = {
	NONE = 0,
	WORKER = 1,
	BARBARIAN = 2
}

function circle_coordinates_generator(r)
	if r == 0 then
		coroutine.yield(0, 0)
	elseif r > 0 then
		for i = 0, r - 1 do
			coroutine.yield(-2 * r + i, i)
			coroutine.yield(-r + 2 * i, r)
			coroutine.yield(r + i, r - i)
			coroutine.yield(2 * r - i, -i)
			coroutine.yield(r - 2 * i, -r)
			coroutine.yield(-r - i, -r + i)
		end
	end
end

function circle_coordinates(r)
	return coroutine.wrap(function() circle_coordinates_generator(r) end)
end

function generate_tile(self, x, y)
	self.map[x][y] = {
		id = nil,
		visible = false,
		active = true,
		landscape = Landscape.PLAINS,
		building = Building.NONE,
		unit = {
			type = Unit.NONE,
			id = nil
		}
	}
end

function generate_circle(self, r)
	for x, y in circle_coordinates(r) do
		generate_tile(self, x, y)
	end
end

function generate_map(self)
	self.map = {}
	for i = -MAP_RADIUS * 2, MAP_RADIUS * 2 do
		self.map[i] = {}
	end
	for r = 0, MAP_RADIUS do
		generate_circle(self, r)
	end
end

function show_tile(self, x, y)
	self.map[x][y].visible = true
	map_update_tile(self, x, y)
end

function show_circle(self, r)
	for x, y in circle_coordinates(r) do
		show_tile(self, x, y)
	end
end

function hide_tile(self, x, y)
	self.map[x][y].visible = false
	map_update_tile(self, x, y)
end

function hide_circle(self, r)
	for x, y in circle_coordinates(r) do
		hide_tile(self, x, y)
	end
end

function set_tile_active(self, x, y, active)
	self.map[x][y].active = active
end
	

function active_filter(self, is_active)
	for r = 0, MAP_RADIUS do
		for x, y in circle_coordinates(r) do
			set_tile_active(self, x, y, is_active(self, x, y))
		end
	end
	map_update(self)
end

function worker_move(self, x, y, tx, ty)
	self.map[x][y].unit.type = Unit.NONE
	self.map[tx][ty].unit.type = Unit.WORKER
	map_update(self)
	-- TODO animation and everything else
end

local function build(self, x, y, building)
	self.map[x][y].building = building
	map_update(self)
	-- TODO animation and everything else
end

function tile_click(self, x, y)
	if self.map[x] ~= nil and self.map[x][y] ~= nil and self.map[x][y].id ~= nil then
		if self.player_turn_state == PlayerTurnState.FREE then
			if self.map[x][y].unit == Unit.WORKER then
				msg.post("gui", hash("render_action"), {options = {"move"}})
			end
		elseif self.player_turn_state == PlayerTurnState.TARGET then
			self.player_turn_state = PlayerTurnState.FREE
		end
	end
end

function spawn_unit(self, x, y, unit)
	self.map[x][y].unit.type = unit
	map_update_tile(self, x, y)
end

function get_radius(x, y)
	return (math.abs(x) + math.abs(y)) / 2
end

function get_distance(x, y, tx, ty)
	return math.max(math.abs(tx - x) / 2, math.abs(ty - y))
end

function enemy_turn(self)

	-- TEST PART
	if self.radius == 2 then
		show_circle(self, 3)
		map_set_radius(self, 3)
	elseif self.radius == 3 then
		show_circle(self, 4)
		map_set_radius(self, 4)
	elseif self.radius == 4 then
		hide_circle(self, 3)
		hide_circle(self, 4)
		map_set_radius(self, 2)
	end
	-- END TEST PART
end

local function ChangeState(self, state)
	if self.state.destroy ~= nil then
		self.state.destroy(self)
	end
	
	self.state = state
	
	if self.state.gui ~= nil then
		msg.post("gui", hash("render"), self.state.gui)
	else
		msg.post("gui", hash("render"), {})
	end
	if self.state.init ~= nil then
		self.state.init(self)
	end
	map_update(self)
end

local TILE_CLICK_MSG = hash("tile_click")
local END_TURN_CLICK_MSG = hash("end_turn_click")
local MOVE_ACTION_CLICK_MSG = hash("move_action_click")
local BUILD_ACTION_CLICK_MSG = hash("build_action_click")
local BACK_CLICK_MSG = hash("back_click")
local FARM_BUILD_CLICK_MSG = hash("farm_build_click")
local SAWMILL_BUILD_CLICK_MSG = hash("sawmill_build_click")

local GameState = {
	None = {},
	Free = {},
	WorkerAction = {},
	WorkerBuild = {},
	EnemyTurn = {},
}

GameState.Free = {
	gui = {
		end_turn = END_TURN_CLICK_MSG
	},
	message_handler = {
		[TILE_CLICK_MSG] = function(self, message)
			if self.map[message.x][message.y].unit.type == Unit.WORKER then
				self.focus.x = message.x
				self.focus.y = message.y
				ChangeState(self, GameState.WorkerAction)
			end
		end,
		[END_TURN_CLICK_MSG] = function(self, message)
			ChangeState(self, GameState.EnemyTurn)
		end,
	}
}

GameState.WorkerAction = {
	gui = {
		end_turn = END_TURN_CLICK_MSG,
		action = {
			move = MOVE_ACTION_CLICK_MSG,
			build = BUILD_ACTION_CLICK_MSG,
			back = BACK_CLICK_MSG
		}
	},
	message_handler = {
		[TILE_CLICK_MSG] = function(self, message)
			if self.map[message.x][message.y].unit.type == Unit.WORKER then
				self.focus.x = message.x
				self.focus.y = message.y
				ChangeState(self, GameState.WorkerAction)
			else
				ChangeState(self, GameState.Free)
			end
		end,
		[MOVE_ACTION_CLICK_MSG] = function(self, message)
			ChangeState(self, GameState.WorkerMove)
		end,
		[BUILD_ACTION_CLICK_MSG] = function(self, message)
			ChangeState(self, GameState.WorkerBuild)
		end,
		[BACK_CLICK_MSG] = function(self, message)
			ChangeState(self, GameState.Free)
		end,
		[END_TURN_CLICK_MSG] = function(self, message)
			ChangeState(self, GameState.EnemyTurn)
		end,
	}
}

GameState.WorkerMove = {
	init = function(self)
		-- TEST
		active_filter(self, function(self, tx, ty)
			return get_distance(self.focus.x, self.focus.y, tx, ty) == 1 and self.map[tx][ty].visible == true
		end)
	end,
	destroy = function(self)
		active_filter(self, function(self, x, y) return true end)
	end,
	gui = {
		action = {
			back = BACK_CLICK_MSG
		}
	},
	message_handler = {
		[TILE_CLICK_MSG] = function(self, message)
			if self.map[message.x][message.y].active then
				worker_move(self, self.focus.x, self.focus.y, message.x, message.y)
				ChangeState(self, GameState.Free)
			end
		end,
		[BACK_CLICK_MSG] = function(self, message)
			ChangeState(self, GameState.WorkerAction)
		end,
	}
}

GameState.WorkerBuild = {
	gui = {
		action = {
			back = BACK_CLICK_MSG
		},
		build = {
			farm = FARM_BUILD_CLICK_MSG,
			sawmill = SAWMILL_BUILD_CLICK_MSG
		}
	},
	message_handler = {
		[FARM_BUILD_CLICK_MSG] = function(self, message)
			build(self, self.focus.x, self.focus.y, Building.FARM)
			ChangeState(self, GameState.Free)
		end,
		[SAWMILL_BUILD_CLICK_MSG] = function(self, message)
			build(self, self.focus.x, self.focus.y, Building.SAWMILL)
			ChangeState(self, GameState.Free)
		end,
		[BACK_CLICK_MSG] = function(self, message)
			ChangeState(self, GameState.WorkerAction)
		end,
	}
}

GameState.EnemyTurn = {
	-- TODO message-based state chane
	init = function(self)
		enemy_turn(self)
		ChangeState(self, GameState.Free)
	end
}

function init(self)
	generate_map(self)
	map_set_radius(self, 2)
	show_circle(self, 0)
	show_circle(self, 1)
	show_circle(self, 2)
	spawn_unit(self, 0, 0, Unit.WORKER)
	self.focus = {}
	self.state = GameState.None
	ChangeState(self, GameState.Free)
	msg.post("camera", "use_projection", { projection = hash("FIXED_AUTO") })
	msg.post(".", "acquire_input_focus")
end

function on_message(self, message_id, message, sender)
	if self.state.message_handler ~= nil and self.state.message_handler[message_id] ~= nil then
		self.state.message_handler[message_id](self, message)
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released then
		local v = camera.screen_to_world(nil, vmath.vector3(action.x, action.y, 0))
		local x, y = world_to_tile(self, v)
		if self.map[x] ~= nil and self.map[x][y] ~= nil and self.map[x][y].id ~= nil then
			msg.post(".", TILE_CLICK_MSG, {x = x, y = y})
		end
	end
end
