TILE_WIDTH = 32
TILE_HEIGHT = 48
PLAY_ZONE_PADDING = 10
SCREEN_WIDTH = 1920
GUI_PLAY_ZONE_WIDTH = 1300
GUI_PLAY_ZONE_HEIGHT = 1080
PLAY_ZONE_WIDTH = GUI_PLAY_ZONE_WIDTH - PLAY_ZONE_PADDING * 2
PLAY_ZONE_HEIGHT = GUI_PLAY_ZONE_HEIGHT - PLAY_ZONE_PADDING * 2
X_SCALED_OFFSET = 0
Y_SCALED_OFFSET = TILE_HEIGHT / 6
X_OFFSET = 0
Y_OFFSET = 0
Z_SCALE = -0.001
UNIX_OFFSET = 0
UNIT_X_SCALED_OFFSET = 0
UNIT_Y_SCALED_OFFSET = TILE_HEIGHT / 6

local camera = require "orthographic.camera"

function world_to_tile(self, v)
	ox = ((v.x - X_OFFSET) / self.scale - X_SCALED_OFFSET) / TILE_WIDTH * 2
	oy = ((v.y - Y_OFFSET) / self.scale - Y_SCALED_OFFSET) / TILE_HEIGHT * 2
	tx = math.floor(ox)
	ty = math.floor(oy)
	x = ox - tx
	y = oy - ty
	if (tx + ty) % 2 == 0 then
		if x + 3 * y > 1 then
			tx = tx + 1
			ty = ty + 1
		end
	else
		if -x + 3 * y > 0 then
			ty = ty + 1
		else
			tx = tx + 1
		end
	end
	return tx, ty
end

function tile_to_world(self, x, y)
	return vmath.vector3(
	(x * TILE_WIDTH / 2 + X_SCALED_OFFSET) * self.scale + X_OFFSET,
	(y * TILE_HEIGHT / 2 + Y_SCALED_OFFSET) * self.scale + Y_OFFSET,
	y * Z_SCALE
	)
end

function unit_to_world(self, x, y)
	return vmath.vector3(
	(x * TILE_WIDTH / 2 + UNIT_X_SCALED_OFFSET) * self.scale + X_OFFSET,
	(y * TILE_HEIGHT / 2 + UNIT_Y_SCALED_OFFSET) * self.scale + Y_OFFSET,
	0)
end

function map_update_tile(self, x, y)
	if self.map[x][y].visible then
		if self.map[x][y].tile_id == nil then
			self.map[x][y].tile_id = factory.create("#hex_factory", tile_to_world(self, x, y), nil, nil, self.scale)
		end
	else
		if self.map[x][y].tile_id ~= nil then
			go.delete(self.map[x][y].tile_id)
			self.map[x][y].tile_id = nil
		end
		return
	end
	if self.map[x][y].unit ~= nil then
		if self.map[x][y].unit_id == nil then
			self.map[x][y].unit_id = factory.create("#unit_factory", unit_to_world(self, x, y), nil, nil, self.scale)
		end
	else
		if self.map[x][y].unit_id ~= nil then
			go.delete(self.map[x][y].unit_id)
			self.map[x][y].unit_id = nil
		end
	end
	local pic = self.map[x][y].landscape.name
	if self.map[x][y].building.type ~= nil then
		pic = self.map[x][y].building.type.name
	end
	if self.map[x][y].lighted == false then
		msg.post(self.map[x][y].tile_id, "play_animation", {id = hash(pic .. "_grey")})
		if self.map[x][y].unit ~= nil then
			--msg.post(self.map[x][y].unit_id, "play_animation", {id = hash(self.map[x][y].unit.name .. "_grey")})
		end
	elseif self.map[x][y].building.type ~= nil and self.map[x][y].building.active == false then
		msg.post(self.map[x][y].tile_id, "play_animation", {id = hash(pic .. "_off")})
	else
		msg.post(self.map[x][y].tile_id, "play_animation", {id = hash(pic)})
	end
	go.animate(self.map[x][y].tile_id, "scale", go.PLAYBACK_ONCE_FORWARD, self.scale, go.EASING_OUTBOUNCE, 1)
	go.animate(self.map[x][y].tile_id, "position", go.PLAYBACK_ONCE_FORWARD, tile_to_world(self, x, y), go.EASING_OUTBOUNCE, 1)
	if self.map[x][y].unit_id ~= nil then
		go.animate(self.map[x][y].unit_id, "scale", go.PLAYBACK_ONCE_FORWARD, self.scale, go.EASING_OUTBOUNCE, 1)
		go.animate(self.map[x][y].unit_id, "position", go.PLAYBACK_ONCE_FORWARD, unit_to_world(self, x, y), go.EASING_OUTBOUNCE, 1)
	end
	-- go.set(self.map[x][y].id, "scale", self.scale)
	-- go.set(self.map[x][y].id, "position", tile_to_world(self, x, y))
end

function map_update(self)
	for r = 0, MAP_RADIUS do
		for x, y in circle_coordinates(r) do
			map_update_tile(self, x, y)
		end
	end
end

function map_set_radius(self, r)
	self.radius = r
	self.scale = math.min(PLAY_ZONE_WIDTH / TILE_WIDTH / (2 * r + 1), PLAY_ZONE_HEIGHT / TILE_WIDTH / (1.5 * r + 1))
	map_update(self)
end

MAP_RADIUS = 4

local Unit = {
	workers = {
		name = "workers"
	},
	barbarians = {
		name = "barbarians"
	},
}

local Landscape = {
	barren = {
		name = "barren",
	},
	wheat = {
		name = "wheat",
	},
	forest = {
		name = "forest",
	},
	stone = {
		name = "stone",
	},
}

local Building = {
	house = {
		name = "house",
		cost = {
			wood = 4
		},
		repair = {
			wood = 2
		},
	},
	farm = {
		name = "farm",
		production = {
			food = 1
		},
		cost = {
			wood = 4
		},
		repair = {
			wood = 2
		},
		require = {
			landscape = {
				Landscape.wheat.name,
			}
		}
	},
	sawmill = {
		name = "sawmill",
		production = {
			wood = 1
		},
		cost = {
			wood = 4
		},
		repair = {
			wood = 2
		},
		require = {
			landscape = {
				Landscape.forest.name,
			}
		}
	},
	quarry = {
		name = "quarry",
		production = {
			stone = 1
		},
		cost = {
			wood = 4
		},
		repair = {
			wood = 2
		},
		require = {
			landscape = {
				Landscape.stone.name,
			}
		}
	},
}

function circle_coordinates_generator(r)
	if r == 0 then
		coroutine.yield(0, 0)
	elseif r > 0 then
		for i = 0, r - 1 do
			coroutine.yield(-2 * r + i, i)
			coroutine.yield(-r + 2 * i, r)
			coroutine.yield(r + i, r - i)
			coroutine.yield(2 * r - i, -i)
			coroutine.yield(r - 2 * i, -r)
			coroutine.yield(-r - i, -r + i)
		end
	end
end

function circle_coordinates(r)
	return coroutine.wrap(function() circle_coordinates_generator(r) end)
end

function generate_tile(self, x, y)
	self.map[x][y] = {
		tile_id = factory.create("#hex_factory", tile_to_world(self, x, y), nil, nil, self.scale),
		unit_id = nil,
		visible = false,
		ligted = true,
		landscape = Landscape.wheat,
		building = {
			type = nil,
			destroyed = false,
			active = false,
		},
		unit = nil
	}
end

function generate_circle(self, r)
	for x, y in circle_coordinates(r) do
		generate_tile(self, x, y)
	end
end

function generate_map(self)
	self.map = {}
	for i = -MAP_RADIUS * 2, MAP_RADIUS * 2 do
		self.map[i] = {}
	end
	for r = 0, MAP_RADIUS do
		generate_circle(self, r)
	end
end

function show_tile(self, x, y)
	self.map[x][y].visible = true
	map_update_tile(self, x, y)
end

function show_circle(self, r)
	for x, y in circle_coordinates(r) do
		show_tile(self, x, y)
	end
end

function hide_tile(self, x, y)
	self.map[x][y].visible = false
	map_update_tile(self, x, y)
end

function hide_circle(self, r)
	for x, y in circle_coordinates(r) do
		hide_tile(self, x, y)
	end
end

function set_tile_active(self, x, y, active)
	self.map[x][y].lighted = active
end
	

function active_filter(self, is_active)
	for r = 0, MAP_RADIUS do
		for x, y in circle_coordinates(r) do
			set_tile_active(self, x, y, is_active(self, x, y))
		end
	end
	map_update(self)
end

function worker_move(self, x, y, tx, ty)
	self.map[x][y].unit = Unit.none
	self.map[tx][ty].unit = Unit.workers
	map_update(self)
	-- TODO animation and everything else
end

local function build(self, x, y, building)
	self.map[x][y].building.type = building
	map_update(self)
	-- TODO animation and everything else
end

function spawn_unit(self, x, y, unit)
	self.map[x][y].unit = unit
	map_update_tile(self, x, y)
end

function get_radius(x, y)
	return (math.abs(x) + math.abs(y)) / 2
end

function get_distance(x, y, tx, ty)
	return math.max(math.abs(tx - x) / 2, math.abs(ty - y))
end

function enemy_turn(self)

	-- TEST PART
	if self.radius == 2 then
		show_circle(self, 3)
		map_set_radius(self, 3)
	elseif self.radius == 3 then
		show_circle(self, 4)
		map_set_radius(self, 4)
	elseif self.radius == 4 then
		hide_circle(self, 3)
		hide_circle(self, 4)
		map_set_radius(self, 2)
	end
	-- END TEST PART
end

local function get_build_options(self, x, y)
	options = {}
	for _, building in pairs(Building) do
		if building.require ~= nil and building.require.landscape ~= nil then
			local landscape_require = false
			for _, landscape in pairs(building.require.landscape) do
				if landscape == self.map[x][y].landscape.name then
					landscape_require = true
				end
			end
			if landscape_require then
				options[building.name] = hash(building.name)
			end
		end
	end
	return options
end

local function ChangeState(self, state)
	if self.state.destroy ~= nil then
		self.state.destroy(self)
	end
	
	self.state = state(self)
	
	if self.state.gui ~= nil then
		msg.post("gui", hash("render"), self.state.gui)
	else
		msg.post("gui", hash("render"), {})
	end
	if self.state.init ~= nil then
		self.state.init(self)
	end
	map_update(self)
end

local TILE_CLICK_MSG = hash("tile_click")
local END_TURN_CLICK_MSG = hash("end_turn_click")
local MOVE_ACTION_CLICK_MSG = hash("move_action_click")
local BUILD_ACTION_CLICK_MSG = hash("build_action_click")
local BACK_CLICK_MSG = hash("back_click")
local FARM_BUILD_CLICK_MSG = hash("farm_build_click")
local SAWMILL_BUILD_CLICK_MSG = hash("sawmill_build_click")

local GameState = {
	None = nil,
	Free = nil,
	WorkerAction = nil,
	WorkerBuild = nil,
	EnemyTurn = nil,
}

GameState.None = function(self)
	return {}
end

GameState.Free = function(self)
	return {
		gui = {
			end_turn = END_TURN_CLICK_MSG
		},
		message_handler = {
			[TILE_CLICK_MSG] = function(self, message)
				if self.map[message.x][message.y].unit == Unit.workers then
					self.focus.x = message.x
					self.focus.y = message.y
					ChangeState(self, GameState.WorkerAction)
				end
			end,
			[END_TURN_CLICK_MSG] = function(self, message)
				ChangeState(self, GameState.EnemyTurn)
			end,
		}
	}
end

GameState.WorkerAction = function(self)
	return {
		gui = {
			end_turn = END_TURN_CLICK_MSG,
			action = {
				move = MOVE_ACTION_CLICK_MSG,
				build = BUILD_ACTION_CLICK_MSG,
				back = BACK_CLICK_MSG
			}
		},
		message_handler = {
			[TILE_CLICK_MSG] = function(self, message)
				if self.map[message.x][message.y].unit == Unit.workers then
					self.focus.x = message.x
					self.focus.y = message.y
					ChangeState(self, GameState.WorkerAction)
				else
					ChangeState(self, GameState.Free)
				end
			end,
			[MOVE_ACTION_CLICK_MSG] = function(self, message)
				ChangeState(self, GameState.WorkerMove)
			end,
			[BUILD_ACTION_CLICK_MSG] = function(self, message)
				ChangeState(self, GameState.WorkerBuild)
			end,
			[BACK_CLICK_MSG] = function(self, message)
				ChangeState(self, GameState.Free)
			end,
			[END_TURN_CLICK_MSG] = function(self, message)
				ChangeState(self, GameState.EnemyTurn)
			end,
		}
	}
end

GameState.WorkerMove = function(self)
	return {
		init = function(self)
			-- TEST
			active_filter(self, function(self, tx, ty)
				return not (get_distance(self.focus.x, self.focus.y, tx, ty) == 1 and self.map[tx][ty].visible == true)
			end)
		end,
		destroy = function(self)
			active_filter(self, function(self, x, y) return true end)
		end,
		gui = {
			action = {
				back = BACK_CLICK_MSG
			}
		},
		message_handler = {
			[TILE_CLICK_MSG] = function(self, message)
				if not self.map[message.x][message.y].lighted then
					worker_move(self, self.focus.x, self.focus.y, message.x, message.y)
					ChangeState(self, GameState.Free)
				end
			end,
			[BACK_CLICK_MSG] = function(self, message)
				ChangeState(self, GameState.WorkerAction)
			end,
		}
	}
end

GameState.WorkerBuild = function(self)
	message_handler = {
		[BACK_CLICK_MSG] = function(self, message)
				ChangeState(self, GameState.WorkerAction)
			end,
		}
	for option, h in pairs(get_build_options(self, self.focus.x, self.focus.y)) do
		message_handler[h] = function(self, message)
			build(self, self.focus.x, self.focus.y, Building[option])
			ChangeState(self, GameState.Free)
		end
	end
	return {
		gui = {
			action = {
				back = BACK_CLICK_MSG
			},
			build = get_build_options(self, self.focus.x, self.focus.y)
		},
		message_handler = message_handler
	}
end

GameState.EnemyTurn = function(self)
	return {
		-- TODO message-based state chane
		init = function(self)
			enemy_turn(self)
			ChangeState(self, GameState.Free)
		end
	}
end

function init(self)
	self.scale = 1
	generate_map(self)
	map_set_radius(self, 2)
	show_circle(self, 0)
	show_circle(self, 1)
	show_circle(self, 2)
	spawn_unit(self, 0, 0, Unit.workers)
	self.focus = {}
	self.state = GameState.None(self)
	ChangeState(self, GameState.Free)
	msg.post("camera", "use_projection", { projection = hash("FIXED_AUTO") })
	msg.post(".", "acquire_input_focus")
end

function on_message(self, message_id, message, sender)
	if self.state.message_handler ~= nil and self.state.message_handler[message_id] ~= nil then
		self.state.message_handler[message_id](self, message)
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released then
		local v = camera.screen_to_world(nil, vmath.vector3(action.x, action.y, 0))
		local x, y = world_to_tile(self, v)
		if self.map[x] ~= nil and self.map[x][y] ~= nil and self.map[x][y].tile_id ~= nil then
			msg.post(".", TILE_CLICK_MSG, {x = x, y = y})
		end
	end
end
